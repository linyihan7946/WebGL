<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>Three框架</title>
        <script src="js/Three.js" data-ke-src="js/Three.js"></script>
        <script src="js/Stats.js"></script><!--性能检测器-->
        <script src="js/tween.min.js" data-ke-src="js/tween.min.js"></script> <!--动画js库-->
        <style type="text/css">
            div#canvas-frame {
                border: none;
                cursor: pointer;
                width: 100%;
                height: 600px;
                background-color: rgb(141, 24, 24);
            }

        </style>
        <script>
            var stats;//性能监视器
            var renderer;//渲染器
            function initThree() {
                width = document.getElementById('canvas-frame').clientWidth;
                height = document.getElementById('canvas-frame').clientHeight;
                renderer = new THREE.WebGLRenderer({
                    antialias : true
                });
                renderer.setSize(width, height);
                document.getElementById('canvas-frame').appendChild(renderer.domElement);
                //renderer.setClearColor(0xFF00FF, 1.0);//setClearColor这个接口不起作用，应该用setClearColorHex
                renderer.setClearColorHex(0xFFFFFF,1.0);//设置渲染器的清除色

                //性能监视器
                stats = new Stats();
                stats.domElement.style.position = 'absolute';
                stats.domElement.style.left = '0px';
                stats.domElement.style.top = '0px';
                document.getElementById('canvas-frame').appendChild(stats.domElement);
            }

            //相机
            var camera;
            var camera_position = new THREE.Vector3( 0, 0, 10000 );
            var camera_up = new THREE.Vector3( 0, 1, 0 );
            var camera_tar = new THREE.Vector3( 0, 0, 0 );
            function setcamera(w, h, near, far, pos, up, tar)
            {
                //不能将视角移动到太远的地方
                var dMax = 15000;
                if (pos.x < -dMax) pos.x = -dMax;
                if (pos.y < -dMax) pos.y = -dMax;
                if (pos.x > dMax) pos.x = dMax;
                if (pos.y > dMax) pos.y = dMax;

                if (tar.x < -dMax) tar.x = -dMax;
                if (tar.y < -dMax) tar.y = -dMax;
                if (tar.x > dMax) tar.x = dMax;
                if (tar.y > dMax) tar.y = dMax;
                //透视投影
                camera = new THREE.PerspectiveCamera(45, width / height, near, far);
                //正视投影
                //camera = new THREE.OrthographicCamera(-w/2,w/2,h/2,-h/2,near,far);
                camera.position = pos;
                camera.up = up;
                camera.lookAt({
                    x : tar.x,
                    y : tar.y,
                    z : tar.z
                });
                camera_position = pos;;
                camera_up = up;
                camera_tar = tar;
            }
            
            //场景
            var scene;
            function initScene() {
                scene = new THREE.Scene();
            }

            //灯光
            var light;
            function initLight() {
                light = new THREE.DirectionalLight(0xFF0000, 1.0, 0);
                light.position.set(100, 100, 200);
                scene.add(light);
            }

            //绘制网格线,因为这个不是在循环里面，所有没有按照nMaxLength的大小实时刷新，所以要一开始把网格线尽量画多
            function initObject_Net() {
                var nLength = 40000;
                var geometry = new THREE.Geometry();
                geometry.vertices.push( new THREE.Vector3( - nLength/2 - camera_position.x, 0, 0 ) );
                geometry.vertices.push( new THREE.Vector3( nLength/2 - camera_position.x, 0, 0 ) );

                var nCount = nLength / 500;
                for ( var i = 0; i <= nCount; i ++ ) {
                    //0x000000
                    var line = new THREE.Line( geometry, new THREE.LineBasicMaterial( { color: 0x000000, opacity: 0.2 } ) );
                    line.position.y = ( i * 500 ) - nLength/2 - camera_position.y;
                    scene.add( line );

                    var line = new THREE.Line( geometry, new THREE.LineBasicMaterial( { color: 0x000000, opacity: 0.2 } ) );
                    line.position.x = ( i * 500 ) - nLength/2 - camera_position.x;
                    line.rotation.z = 90 * Math.PI / 180;
                    scene.add( line );

                }
            }

            //绘制彩色线条
            var cube;//立体物体
            function initObject() {

                /*
                var geometry = new THREE.Geometry();
                var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors} );
                var color1 = new THREE.Color( 0x444444 ), color2 = new THREE.Color( 0xFF0000 );
                // 线的材质可以由2点的颜色决定
                var p1 = new THREE.Vector3( -100, 100, 0 );
                var p2 = new THREE.Vector3(  100, -100, 0 );
                geometry.vertices.push(p1);
                geometry.vertices.push(p2);
                geometry.colors.push( color1, color2 );
                var line = new THREE.Line( geometry, material, THREE.LinePieces );
                scene.add(line);
                */

                //三角面
                var l = 6000, w = 4000, h = 2800;
                
                {//地面
                    var g = new THREE.Geometry();
                    g.vertices.push(
                    //从房间顶部向下看
                    new THREE.Vector3( -l/2, -w/2, 0 ),//下-左下
                    new THREE.Vector3( l/2, -w/2, 0 ),//下-右下
                    new THREE.Vector3( l/2, w/2, 0 ),//下-右上
                    new THREE.Vector3( -l/2, w/2, 0 ),//下-左上

                    new THREE.Vector3( -l/2, -w/2, h ),//上-左下
                    new THREE.Vector3( l/2, -w/2, h ),//上-右下
                    new THREE.Vector3( l/2, w/2, h ),//上-右上
                    new THREE.Vector3( -l/2, w/2, h ),//上-左上 
                    );
                    g.faces.push( new THREE.Face3( 0, 1, 2 ) );
                    g.faces.push( new THREE.Face3( 0, 2, 3 ) );
                    g.computeBoundingSphere();
                    var material = new THREE.MeshBasicMaterial({color:0xff0000});
                    var mesh = new THREE.Mesh( g,material );
                    scene.add( mesh );
                }
                {//左
                    var g = new THREE.Geometry();
                    g.vertices.push(
                    //从房间顶部向下看
                    new THREE.Vector3( -l/2, -w/2, 0 ),//下-左下
                    new THREE.Vector3( l/2, -w/2, 0 ),//下-右下
                    new THREE.Vector3( l/2, w/2, 0 ),//下-右上
                    new THREE.Vector3( -l/2, w/2, 0 ),//下-左上

                    new THREE.Vector3( -l/2, -w/2, h ),//上-左下
                    new THREE.Vector3( l/2, -w/2, h ),//上-右下
                    new THREE.Vector3( l/2, w/2, h ),//上-右上
                    new THREE.Vector3( -l/2, w/2, h ),//上-左上 
                    );
                    g.faces.push( new THREE.Face3( 0, 3, 7 ) );
                    g.faces.push( new THREE.Face3( 0, 7, 4 ) );
                    g.computeBoundingSphere();
                    var material = new THREE.MeshBasicMaterial({color:0x000000});
                    var mesh = new THREE.Mesh( g,material );
                    scene.add( mesh );
                }
            }

            

            //绘制一个立体物体
            var mesh;

            //贴图
            function initObject_Texture(){
                //构造一个500*300的平面
                var geometry = new THREE.PlaneGeometry( 500, 300, 1, 1 );
                geometry.vertices[0].uv = new THREE.Vector2(0,0);
                geometry.vertices[1].uv = new THREE.Vector2(2,0);
                geometry.vertices[2].uv = new THREE.Vector2(2,2);
                geometry.vertices[3].uv = new THREE.Vector2(0,2);
                // 加载贴图必须是网上的不能是本地的
                var texPath = "scene/HomeKooTemp78257_2/tex/1C3BA531_195003.jpg";
                var texture = THREE.ImageUtils.loadTexture(texPath/*"textures/1.bmp"*/,null,function(t){});
                var material = new THREE.MeshBasicMaterial({map:texture});
                var mesh1 = new THREE.Mesh( geometry,material );
                scene.add( mesh1 );
            }

            
            function Entity()
            {
                this.geometry = new THREE.Geometry();
                this.id = 0;
                this.motion_type = 0;
                this.motion_pos = new THREE.Vector2(0,0,0);
                this.motion_vec = new THREE.Vector2(0,0,1);
                this.motion_valuecur = 0;
                this.motion_valuemin = 0;
                this.motion_valuemax = 0;
            }

            //解析xml文件
            function parseXML(xmlFile){
                // 创建解析XML后的DOM对象
                var xmlDoc = null;
                // 根据不同浏览器进行解析
                if(window.DOMParser){
                    // 其他浏览器  
                    alert("window.DOMParser");
                    var parser = new DOMParser();
                    alert("window.DOMParser-1");
                    xmlDoc = parser.parseFromString(xmlFile,"application/xml");
                    alert("window.DOMParser-2");
                }else{
                    // IE浏览器
                    alert("!window.DOMParser");
                    xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
                    xmlDoc.async = false;
                    xmlDoc.loadXML(xmlFile);
                    alert("!window.DOMParser_2");
                }
                return xmlDoc;
            }

            function parseXML2(xmlFile)
            {
                alert("parseXML2——1");
                    var xmlDoc=null;
                    //判断浏览器的类型
                    //支持IE浏览器
                    if(!window.DOMParser && window.ActiveXObject)
                    {
                        alert("!window.DOMParser && window.ActiveXObject");
                        var xmlDomVersions = ['MSXML.2.DOMDocument.6.0','MSXML.2.DOMDocument.3.0','Microsoft.XMLDOM'];
                        for(var i=0;i<xmlDomVersions.length;i++){
                            try{
                                xmlDoc = new ActiveXObject(xmlDomVersions[i]);
                                break;
                            }catch(e){
                            }
                        }
                    }
                    //支持Mozilla浏览器
                    else if(document.implementation && document.implementation.createDocument)
                    {
                        alert("支持Mozilla浏览器");
                        try{
                            /* document.implementation.createDocument('','',null); 方法的三个参数说明
                            * 第一个参数是包含文档所使用的命名空间URI的字符串； 
                            * 第二个参数是包含文档根元素名称的字符串； 
                            * 第三个参数是要创建的文档类型（也称为doctype）
                            */
                            xmlDoc = document.implementation.createDocument('','',null);
                        }catch(e){
                        }
                    }
                    else
                    {
                        alert("返回null");
                        return null;
                    }
                    alert("parseXML2——3");
                    if(xmlDoc!=null)
                    {
                        xmlDoc.async = false;
                        alert("parseXML2——3.2");
                        xmlDoc.load(xmlFile);
                        alert("parseXML2——3.3");
                    }
                    alert("parseXML2——4");
                    return xmlDoc;
            }

            //加载xml文件
            function loadXMLDoc(dname) 
            {
                var xmlDoc;
                try //Internet Explorer
                {
                    alert("loadXMLDoc_1");
                    xmlDoc=new ActiveXObject("Microsoft.XMLDOM");
                }
                catch(e)
                {
                    try //Firefox, Mozilla, Opera, etc.
                    {
                        alert("loadXMLDoc_2");
                        xmlDoc=document.implementation.createDocument("","",null);
                    }
                    catch(e) 
                    {
                        alert(e.message);
                    }
                }
                try 
                {
                    alert("loadXMLDoc_3");
                    xmlDoc.async=false;
                    xmlDoc.load(dname);
                    alert("loadXMLDoc_4");
                    return(xmlDoc);
                }
                catch(e) 
                {
                    alert("loadXMLDoc_5");
                    //webkit BUG,chrome etc.
                    xmlDoc = new XMLHttpRequest(); //用AJAX中常见的套路来就可以解决了，不影响IE、FIREFOX的原生加载XML 
                    xmlDoc.overrideMimeType("text/xml");
                    xmlDoc.open("GET", dname, false);
                    xmlDoc.send(null);
                    //xmlResult = xmlDoc.responseXML; 
                    alert("loadXMLDoc_6");
                    return xmlDoc;

                    //alert(e.message);
                }
                return(null);
            }

            function loadXMLDoc1(dname)
            {
                var xmlDoc;

                // 针对 IE 的代码
                if (window.ActiveXObject)
                {
                xmlDoc=new ActiveXObject("Microsoft.XMLDOM");
                }

                // 针对 Mozilla、Firefox、Opera 的代码
                else if (document.implementation && document.implementation.createDocument)
                {
                xmlDoc=document.implementation.createDocument("","",null);
                }

                else
                {
                alert('您的浏览器无法处理此脚本');
                }

                alert('loadXMLDoc1-1');
                xmlDoc.async=false;
                xmlDoc.load(dname);
                alert('loadXMLDoc1-2');
                return(xmlDoc);
            }

            //加载xml可用版本（火狐浏览器可以、谷歌浏览器不行）
            function loadXMLDoc2(xmlFile) 
            {
                var xmlDoc;
                if (window.ActiveXObject) 
                {//IE浏览器
                    xmlDoc = new ActiveXObject('Microsoft.XMLDOM');
                    xmlDoc.async = false;
                    xmlDoc.load(xmlFile);
                }
                else if (isFirefox=navigator.userAgent.indexOf("Firefox")>0) 
                {//火狐浏览器
                    xmlDoc = document.implementation.createDocument('', '', null);
                    xmlDoc.load(xmlFile);
                }
                else
                { //谷歌浏览器（经过测试不可用）
                    var xmlhttp = new window.XMLHttpRequest();
                    xmlhttp.open("GET",xmlFile,false);
                    xmlhttp.send(null);
                    if(xmlhttp.readyState == 4)
                        xmlDoc = xmlhttp.responseXML.documentElement;
                }

                return xmlDoc;
            }

            var entCount = 0;
            function getEntity(ent, element1)
            {
                var i, j, k, l, m, n;
                
                /*
                if ('Entity' == element1.nodeName)//Entity
                {
                    alert(element1.nodeName + entCount);
                    entCount++;
                }
                else if ('Surface' == element1.nodeName)//mesh数据
                {
                    alert(element1.nodeName + entCount);
                    entCount++;
                }
                else if ('Attr' == element1.nodeName)//mesh数据
                {
                    alert(element1.nodeName + entCount);
                    entCount++;
                }
                */
                

                for (k = 0; k < element1.childNodes.length; k++)//拿到子节点的信息
                {
                    var element2 = element1.childNodes[k];
                    if ('Entity' == element2.nodeName)//Entity
                    {
                        getEntity(ent, element2);
                    }
                    else if ('Surface' == element2.nodeName)//mesh数据
                    {
                        //alert(element2.nodeName);
                        for (l = 0; l < element2.childNodes.length; l++)
                        {
                            var element3 = element2.childNodes[l];
                            if ('Mesh' == element3.nodeName)
                            {
                                //var material = new THREE.MeshBasicMaterial();//拿到该表面的材质
                                for (m = 0; m < element3.childNodes.length; m++)
                                {
                                    var element4 = element3.childNodes[m];
                                    if ('mat' == element4.nodeName)//贴图信息
                                    {
                                        for (n = 0; n < element4.childNodes.length; n++)
                                        {
                                            var element5 = element4.childNodes[n];
                                            if ('map' == element5.nodeName)
                                            {
                                                var sValue = element5.childNodes[0].nodeValue;//这里不能直接用element5.nodeValue
                                                // 加载贴图必须是网上的不能是本地的
                                                var texPath = "scene/HomeKooTemp78257_2/tex/" + sValue + ".jpg";
                                                var texture = THREE.ImageUtils.loadTexture(texPath,null,function(t){});
                                                //material.map = texture;
                                            }
                                            else if ('c' == element5.nodeName)
                                            {

                                            }
                                        }
                                    }
                                    else if ('vert' == element4.nodeName)//顶点信息
                                    {
                                        var arVert, arTexture, arIndex;//顶点、贴图坐标、索引
                                        for (n = 0; n < element4.childNodes.length; n++)
                                        {
                                            var element5 = element4.childNodes[n];
                                            if ('v' == element5.nodeName)
                                            {
                                                var sValue = element5.childNodes[0].nodeValue;//这里不能直接用element5.nodeValue
                                                sValue = sValue.trim();//去除前后空格
                                                arVert = sValue.split(' ');//通过空格分开拿到数据
                                            }
                                            else if ('vt' == element5.nodeName)
                                            {
                                                var sValue = element5.childNodes[0].nodeValue;//这里不能直接用element5.nodeValue
                                                sValue = sValue.trim();//去除前后空格
                                                arTexture = sValue.split(' ');//通过空格分开拿到数据
                                            }
                                            else if ('vi' == element5.nodeName)
                                            {
                                                var sValue = element5.childNodes[0].nodeValue;//这里不能直接用element5.nodeValue
                                                sValue = sValue.trim();//去除前后空格
                                                arIndex = sValue.split(' ');//通过空格分开拿到数据
                                            }
                                        }
                                        
                                        var l1 = arVert.length;
                                        var l2 = arTexture.length;
                                        var l3 = arIndex.length;
                                        //alert(l1 + ',' + l2 + ',' + l3);
                                        if (l1 == l2 && l1 / 3 * 2 == l3)
                                        {
                                            //alert('顶点数、贴图坐标数和顶点索引数正确');
                                            var geometry = new THREE.Geometry();
                                            for (n = 0; n < l1; n+=3)
                                            {
                                                geometry.vertices.push(new THREE.Vector3( arVert[n], arVert[n+1], arVert[n+2] ));
                                            }
                                            for (n = 0; n < l1; n+=3)
                                            {
                                                var index = n / 3;
                                                //alert(index+':'+arTexture[n]+arTexture[n+1]);
                                                geometry.vertices[index].uv = new THREE.Vector2( arTexture[n], arTexture[n+1]);
                                            }
                                            for (n = 0; n < l3; n+=6)
                                            {
                                                geometry.faces.push( new THREE.Face3( arIndex[n], arIndex[n+2], arIndex[n+4] ) );
                                            }
                                            geometry.computeBoundingSphere();
                                            var material = new THREE.MeshBasicMaterial({color:0x000000});
                                            var mesh = new THREE.Mesh( geometry,material );
                                            scene.add( mesh );
                                        }
                                    }
                                }
                            }
                        }
                    }
                    else if ('Attr' == element2.nodeName)//Attr属性
                    {
                        //alert(element2.nodeName);
                        for (l = 0; l < element2.childNodes.length; l++)
                        {
                            var element3 = element2.childNodes[l];
                            if ('id' == element3.nodeName)
                            {

                            }
                            else if ('motion_type' == element3.nodeName)
                            {

                            }
                            else if ('motion_pos' == element3.nodeName)
                            {

                            }
                            else if ('motion_vec' == element3.nodeName)
                            {

                            }
                            else if ('motion_valuecur' == element3.nodeName)
                            {

                            }
                            else if ('motion_valuemin' == element3.nodeName)
                            {

                            }
                            else if ('motion_valuemax' == element3.nodeName)
                            {

                            }
                        }
                    }
                }
            }

            //加载3DShow场景
            function loadScene_3DShow(sceneName)
            {                
                //2AECA33B_1617378
                //2B58D52C_21900
                //Test
                var xmlfile = "scene/" + sceneName + "/scenedata/2AECA33B_1617378.xml";//一定要把vvf改名为xml才能加载
                var xmlDoc=loadXMLDoc2(xmlfile);
                alert(xmlDoc);//要弹出这个后面才能读到数据，可能时异步加载xml导致的问题
                var vvf = xmlDoc.getElementsByTagName("vvFile");//vvFile
                //alert(vvf.length);
                
                //根节点vvFile
                //子节点Entity(vvFile只有一个Entity子节点，没有Attr)
                //Entity的子节点：多个Entity和一个Attr或者有Surface
                //Entity递归
                //Attr子节点:id、motion_type、motion_pos、motion_vec、motion_valuecur、motion_valuemin、motion_valuemax
                //Surface子节点:Mesh
                //Mesh子节点：mat、vert
                //mat子节点：map、c
                //vert子节点：v、vt、vi
                var i, j, k, l, m, n;
                for (i = 0; i < vvf.length; i++)//vvFile 
                {
                    alert(vvf[i].nodeName);
                    for (j = 0; j < vvf[i].childNodes.length; j++)//拿到子节点的信息
                    {
                        var element1 = vvf[i].childNodes[j];
                        var ent = new Entity();
                        getEntity(ent, element1);
                    }         
                }
            }
            
            //构造动画
            /*
             TWEEN.Tween的构造函数接受的是要改变属性的对象，这里传入的是mesh的位置。
             Tween的任何一个函数返回的都是自身，所以可以用串联的方式直接调用各个函数。
            to函数，接受两个参数，第一个参数是一个集合，里面存放的键值对，键x表示mesh.position的x属性，值-400表示，动画结束的时候需要移动到的位置。
            第二个参数，是完成动画需要的时间，这里是3000ms。
            repeat( Infinity )表示重复无穷次，也可以接受一个整形数值，例如5次。
            Start表示开始动画，默认情况下是匀速的将mesh.position.x移动到-400的位置。 
            */
            function initTween()
            {
                new TWEEN.Tween( mesh.position)
                        .to( { x: -400 }, 3000 ).repeat( Infinity ).start();
            }

            
            //鼠标交互相关函数
            function addEvent(obj,xEvent,fn) 
            {  
                if(obj.attachEvent){  
                obj.attachEvent('on'+xEvent,fn);  
                }else{  
                obj.addEventListener(xEvent,fn,false);  
                }  
            }  

            var nMaxLength = 10000;//视图大小
            function render()
            {
                //实时计算相机
                var windowWidth = 0, windowHeight = 0;
                if (window.innerWidth >= window.innerHeight)
                {
                    windowWidth = nMaxLength;
                    windowHeight = nMaxLength * window.innerHeight / window.innerWidth;
                }
                else
                {
                    windowHeight = nMaxLength;
                    windowWidth = nMaxLength * window.innerWidth / window.innerHeight;
                }

                setcamera(windowWidth,windowHeight, 10, 10000, camera_position, camera_up, camera_tar);

                //以下两句为动画效果
                //camera.position.x =camera.position.x +1;//视图移动
                //mesh.position.x += 1;//物体移动
                
                //renderer.clear();                
                renderer.render(scene, camera);
                requestAnimationFrame(render);

                //实时刷新性能检测器
                stats.update();

                //如果不用上面的方式，就可以用这种方式去实现动画效果
                //TWEEN.update();
            }

            function threeStart() {
                
                //鼠标滑轮消息
                var oDiv = document.getElementById('canvas-frame');  
                function onMouseWheel(ev) 
                {//当鼠标滚轮事件发生时，执行一些操作
                    var ev = ev || window.event;  
                    var down = true; // 定义一个标志，当滚轮向下滚时，执行一些操作  
                    down = ev.wheelDelta?ev.wheelDelta<0:ev.detail>0;  
                    if(down)
                    {  
                        nMaxLength+=500;
                        if (nMaxLength > 20000)
                            nMaxLength = 20000;
                    }
                    else
                    {  
                        nMaxLength-=500;
                        if (nMaxLength < 2000)
                            nMaxLength = 2000; 
                    }  
                    if(ev.preventDefault)
                    {//FF 和 Chrome
                        ev.preventDefault();// 阻止默认事件  
                    }  
                    return false;  
                }  
                addEvent(oDiv,'mousewheel',onMouseWheel);  
                addEvent(oDiv,'DOMMouseScroll',onMouseWheel); 

                //鼠标移动消息:计算camera_position和camera_tar
                oDiv.onmousedown=function(ev)
                {
                    var e=window.event || ev;
                    var oX=e.clientX;
                    var oY=e.clientY;
                    document.onmousemove=function(ev)
                    {
                        var e=window.event|| ev;
                        var scale = 1.0;
                        if (window.innerWidth >= window.innerHeight)
                            scale = nMaxLength/window.innerWidth;
                        else
                            scale = nMaxLength/window.innerHeight;
                        var moveX = (e.clientX-oX)*scale;
                        var moveY = (e.clientY-oY)*scale;
                        camera_position.x -= moveX;
                        camera_position.y += moveY;
                        camera_tar.x -= moveX;
                        camera_tar.y += moveY;
                        oX = e.clientX;
                        oY = e.clientY;
                    }
                    document.onmouseup=function()//当鼠标按键抬起，清除移动事件
                    {
                        document.onmousemove=null;
                        document.onmouseup=null;
                    }
                }
                
                initThree();
                initScene();
                initLight();
                initObject_Net();
                initObject();
		
		        loadScene_3DShow("HomeKooTemp78257_2");
                initObject_Texture();
                //initTween();//初始化动画
                render();
            }

        </script>
    </head>

    <body onload="threeStart();">
        <div id="canvas-frame"></div>
    </body>
</html>
