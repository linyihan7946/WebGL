<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>Three框架</title>
        <script src="js/Three.js" data-ke-src="js/Three.js"></script>
        <script src="js/Stats.js"></script><!--性能检测器-->
        <script src="js/tween.min.js" data-ke-src="js/tween.min.js"></script> <!--动画js库-->
        <style type="text/css">
            div#canvas-frame {
                border: none;
                cursor: pointer;
                width: 100%;
                height: 600px;
                background-color: rgb(141, 24, 24);
            }

        </style>
        <script>
            var stats;//性能监视器
            var renderer;//渲染器
            function initThree() {
                width = document.getElementById('canvas-frame').clientWidth;
                height = document.getElementById('canvas-frame').clientHeight;
                renderer = new THREE.WebGLRenderer({
                    antialias : true
                });
                renderer.setSize(width, height);
                document.getElementById('canvas-frame').appendChild(renderer.domElement);
                //renderer.setClearColor(0xFF00FF, 1.0);//setClearColor这个接口不起作用，应该用setClearColorHex
                renderer.setClearColorHex(0xFFFFFF,1.0);//设置渲染器的清除色

                //性能监视器
                stats = new Stats();
                stats.domElement.style.position = 'absolute';
                stats.domElement.style.left = '0px';
                stats.domElement.style.top = '0px';
                document.getElementById('canvas-frame').appendChild(stats.domElement);
            }

            //相机
            var camera;
            var camera_position = new THREE.Vector3( 0, 0, 10000 );
            var camera_up = new THREE.Vector3( 0, 1, 0 );
            var camera_tar = new THREE.Vector3( 0, 0, 0 );
            function setcamera(w, h, near, far, 
                                posx, posy, posz, 
                                upx, upy, upz, 
                                tarx, tary, tarz)
            {
                //不能将视角移动到太远的地方
                var dMax = 15000;
                if (posx < -dMax) posx = -dMax;
                if (posy < -dMax) posy = -dMax;
                if (posx > dMax) posx = dMax;
                if (posy > dMax) posy = dMax;

                if (tarx < -dMax) tarx = -dMax;
                if (tary < -dMax) tary = -dMax;
                if (tarx > dMax) tarx = dMax;
                if (tary > dMax) tary = dMax;
                //透视投影
                camera = new THREE.PerspectiveCamera(45, width / height, near, far);
                //正视投影
                //camera = new THREE.OrthographicCamera(-w/2,w/2,h/2,-h/2,near,far);
                camera.position.x = posx;
                camera.position.y = posy;
                camera.position.z = posz;
                camera.up.x = upx;
                camera.up.y = upy;
                camera.up.z = upz;
                camera.lookAt({
                    x : tarx,
                    y : tary,
                    z : tarz
                });
                camera_position.set(posx, posy, posz);
                camera_up.set(upx, upy, upz);
                camera_tar.set(tarx, tary, tarz);
            }
            
            //场景
            var scene;
            function initScene() {
                scene = new THREE.Scene();
            }

            //灯光
            var light;
            function initLight() {
                light = new THREE.DirectionalLight(0xFF0000, 1.0, 0);
                light.position.set(100, 100, 200);
                scene.add(light);
            }

            //绘制网格线,因为这个不是在循环里面，所有没有按照nMaxLength的大小实时刷新，所以要一开始把网格线尽量画多
            function initObject_Net() {
                var nLength = 40000;
                var geometry = new THREE.Geometry();
                geometry.vertices.push( new THREE.Vector3( - nLength/2 - camera_position.x, 0, 0 ) );
                geometry.vertices.push( new THREE.Vector3( nLength/2 - camera_position.x, 0, 0 ) );

                var nCount = nLength / 500;
                for ( var i = 0; i <= nCount; i ++ ) {
                    //0x000000
                    var line = new THREE.Line( geometry, new THREE.LineBasicMaterial( { color: 0x000000, opacity: 0.2 } ) );
                    line.position.y = ( i * 500 ) - nLength/2 - camera_position.y;
                    scene.add( line );

                    var line = new THREE.Line( geometry, new THREE.LineBasicMaterial( { color: 0x000000, opacity: 0.2 } ) );
                    line.position.x = ( i * 500 ) - nLength/2 - camera_position.x;
                    line.rotation.z = 90 * Math.PI / 180;
                    scene.add( line );

                }
            }

            //绘制彩色线条
            var cube;//立体物体
            function initObject() {

                /*
                var geometry = new THREE.Geometry();
                var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors} );
                var color1 = new THREE.Color( 0x444444 ), color2 = new THREE.Color( 0xFF0000 );
                // 线的材质可以由2点的颜色决定
                var p1 = new THREE.Vector3( -100, 100, 0 );
                var p2 = new THREE.Vector3(  100, -100, 0 );
                geometry.vertices.push(p1);
                geometry.vertices.push(p2);
                geometry.colors.push( color1, color2 );
                var line = new THREE.Line( geometry, material, THREE.LinePieces );
                scene.add(line);
                */

                //三角面
                var l = 6000, w = 4000, h = 2800;
                
                {//地面
                    var geometry = new THREE.Geometry();
                    geometry.vertices.push(
                    //从房间顶部向下看
                    new THREE.Vector3( -l/2, -w/2, 0 ),//下-左下
                    new THREE.Vector3( l/2, -w/2, 0 ),//下-右下
                    new THREE.Vector3( l/2, w/2, 0 ),//下-右上
                    new THREE.Vector3( -l/2, w/2, 0 ),//下-左上

                    new THREE.Vector3( -l/2, -w/2, h ),//上-左下
                    new THREE.Vector3( l/2, -w/2, h ),//上-右下
                    new THREE.Vector3( l/2, w/2, h ),//上-右上
                    new THREE.Vector3( -l/2, w/2, h ),//上-左上 
                    );
                    var g = geometry;
                    g.faces.push( new THREE.Face3( 0, 1, 2 ) );
                    g.faces.push( new THREE.Face3( 0, 2, 3 ) );
                    g.computeBoundingSphere();
                    var material = new THREE.MeshBasicMaterial({color:0xff0000});
                    var mesh = new THREE.Mesh( g,material );
                    scene.add( mesh );
                }
                {//左
                    var geometry = new THREE.Geometry();
                    geometry.vertices.push(
                    //从房间顶部向下看
                    new THREE.Vector3( -l/2, -w/2, 0 ),//下-左下
                    new THREE.Vector3( l/2, -w/2, 0 ),//下-右下
                    new THREE.Vector3( l/2, w/2, 0 ),//下-右上
                    new THREE.Vector3( -l/2, w/2, 0 ),//下-左上

                    new THREE.Vector3( -l/2, -w/2, h ),//上-左下
                    new THREE.Vector3( l/2, -w/2, h ),//上-右下
                    new THREE.Vector3( l/2, w/2, h ),//上-右上
                    new THREE.Vector3( -l/2, w/2, h ),//上-左上 
                    );

                    var g = geometry;
                    g.faces.push( new THREE.Face3( 0, 3, 7 ) );
                    g.faces.push( new THREE.Face3( 0, 7, 4 ) );
                    g.computeBoundingSphere();
                    var material = new THREE.MeshBasicMaterial({color:0x000000});
                    var mesh = new THREE.Mesh( g,material );
                    scene.add( mesh );
                }
            }

            

            //绘制一个立体物体
            var mesh;

            //贴图
            function initObject_Texture(){
                //构造一个500*300的平面
                var geometry = new THREE.PlaneGeometry( 500, 300, 1, 1 );
                geometry.vertices[0].uv = new THREE.Vector2(0,0);
                geometry.vertices[1].uv = new THREE.Vector2(2,0);
                geometry.vertices[2].uv = new THREE.Vector2(2,2);
                geometry.vertices[3].uv = new THREE.Vector2(0,2);
                // 加载贴图必须是网上的不能是本地的
                var texture = THREE.ImageUtils.loadTexture("textures/1.bmp",null,function(t){});
                var material = new THREE.MeshBasicMaterial({map:texture});
                var mesh1 = new THREE.Mesh( geometry,material );
                scene.add( mesh1 );
            }

            //构造动画
            /*
             TWEEN.Tween的构造函数接受的是要改变属性的对象，这里传入的是mesh的位置。
             Tween的任何一个函数返回的都是自身，所以可以用串联的方式直接调用各个函数。
            to函数，接受两个参数，第一个参数是一个集合，里面存放的键值对，键x表示mesh.position的x属性，值-400表示，动画结束的时候需要移动到的位置。
            第二个参数，是完成动画需要的时间，这里是3000ms。
            repeat( Infinity )表示重复无穷次，也可以接受一个整形数值，例如5次。
            Start表示开始动画，默认情况下是匀速的将mesh.position.x移动到-400的位置。 
            */
            function initTween()
            {
                new TWEEN.Tween( mesh.position)
                        .to( { x: -400 }, 3000 ).repeat( Infinity ).start();
            }

            
            //鼠标交互相关函数
            function addEvent(obj,xEvent,fn) 
            {  
                if(obj.attachEvent){  
                obj.attachEvent('on'+xEvent,fn);  
                }else{  
                obj.addEventListener(xEvent,fn,false);  
                }  
            }  

            var nMaxLength = 10000;//视图大小
            function render()
            {
                //实时计算相机
                var windowWidth = 0, windowHeight = 0;
                if (window.innerWidth >= window.innerHeight)
                {
                    windowWidth = nMaxLength;
                    windowHeight = nMaxLength * window.innerHeight / window.innerWidth;
                }
                else
                {
                    windowHeight = nMaxLength;
                    windowWidth = nMaxLength * window.innerWidth / window.innerHeight;
                }

                setcamera(windowWidth,windowHeight, 10, 10000, 
                            camera_position.x, camera_position.y ,camera_position.z, 
                            camera_up.x, camera_up.y, camera_up.z, 
                            camera_tar.x, camera_tar.y, camera_tar.z);

                //以下两句为动画效果
                //camera.position.x =camera.position.x +1;//视图移动
                //mesh.position.x += 1;//物体移动
                
                //renderer.clear();                
                renderer.render(scene, camera);
                requestAnimationFrame(render);

                //实时刷新性能检测器
                stats.update();

                //如果不用上面的方式，就可以用这种方式去实现动画效果
                //TWEEN.update();
            }

            function threeStart() {
                
                //鼠标滑轮消息
                var oDiv = document.getElementById('canvas-frame');  
                function onMouseWheel(ev) 
                {//当鼠标滚轮事件发生时，执行一些操作
                    var ev = ev || window.event;  
                    var down = true; // 定义一个标志，当滚轮向下滚时，执行一些操作  
                    down = ev.wheelDelta?ev.wheelDelta<0:ev.detail>0;  
                    if(down)
                    {  
                        nMaxLength+=500;
                        if (nMaxLength > 20000)
                            nMaxLength = 20000;
                    }
                    else
                    {  
                        nMaxLength-=500;
                        if (nMaxLength < 2000)
                            nMaxLength = 2000; 
                    }  
                    if(ev.preventDefault)
                    {//FF 和 Chrome
                        ev.preventDefault();// 阻止默认事件  
                    }  
                    return false;  
                }  
                addEvent(oDiv,'mousewheel',onMouseWheel);  
                addEvent(oDiv,'DOMMouseScroll',onMouseWheel); 

                //鼠标移动消息:计算camera_position和camera_tar
                oDiv.onmousedown=function(ev)
                {
                    var e=window.event || ev;
                    var oX=e.clientX;
                    var oY=e.clientY;
                    document.onmousemove=function(ev)
                    {
                        var e=window.event|| ev;
                        var scale = 1.0;
                        if (window.innerWidth >= window.innerHeight)
                            scale = nMaxLength/window.innerWidth;
                        else
                            scale = nMaxLength/window.innerHeight;
                        var moveX = (e.clientX-oX)*scale;
                        var moveY = (e.clientY-oY)*scale;
                        camera_position.x -= moveX;
                        camera_position.y += moveY;
                        camera_tar.x -= moveX;
                        camera_tar.y += moveY;
                        oX = e.clientX;
                        oY = e.clientY;
                    }
                    document.onmouseup=function()//当鼠标按键抬起，清除移动事件
                    {
                        document.onmousemove=null;
                        document.onmouseup=null;
                    }
                }
                
                initThree();
                initScene();
                initLight();
                initObject_Net();
                initObject();
                //initObject_Texture();
                //initTween();//初始化动画
                render();
            }

        </script>
    </head>

    <body onload="threeStart();">
        <div id="canvas-frame"></div>
    </body>
</html>
